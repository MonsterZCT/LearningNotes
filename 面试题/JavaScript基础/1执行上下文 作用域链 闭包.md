# 执行上下文 作用域链 闭包

## 执行上下文

执行上下文类型：

1. 全局上下文
2. 函数执行上下文
3. Eval函数执行上下文

对于每个执行上下文，都有三个重要属性：

- 变量对象(Variable object，VO)
- 作用域链(Scope chain)
- this

在 JavaScript 代码执行前，执行上下文将经历创建阶段。在创建阶段会发生三件事：

1. **this** 值的决定，即我们所熟知的 **This 绑定**。
2. 创建**词法环境**组件。
3. 创建**变量环境**组件。

#### 生命周期

1. 创建阶段，在这个阶段，执行上下文会分别创建变量对象，确认作用域链，以及确 th is 的指向
2. 执行阶段，创建阶段之后，就开始执行代码，这个时候会完成变量赋值、函数引用，以及执行其他可执行代码

#### 变量对象

1. 函数的所有参数（ Firefox 中为参数对象 arguments）
2. 当前上下文中的所有函数声明（通过 function 声明的函数）
3. 当前上下文中的所有变量声明（通过 var 声明的变量）

#### 活动对象

在函数调用战中，如果当前执行上下文处于函数调用钱的楼顶，则意味着当前上下文处于激活状态， 此时变量对象称之为活动对象（ AO, Activation Object 活动对象中包含变量对象的所有属性，并且此时所有的属性都已经完成了赋值，除 之外，活动对象还包含了 this 的指向



#### 作用域增强

1. try/catch语句的catch
2. with语句



#### **This 绑定：**

在全局执行上下文中，`this` 的值指向全局对象。(在浏览器中，`this`引用 Window 对象)。

在函数执行上下文中，`this` 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 `this` 会被设置成那个对象，否则 `this` 的值被设置为全局对象或者 `undefined`（在严格模式下）。



#### 词法环境

[官方的 ES6](http://ecma-international.org/ecma-262/6.0/) 文档把词法环境定义为

> **词法环境**是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义**标识符**和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用**外部**词法环境的空值组成。

简单来说**词法环境**是一种持有**标识符—变量映射**的结构。（这里的**标识符**指的是变量/函数的名字，而**变量**是对实际对象[包含函数类型对象]或原始数据的引用）。

现在，在词法环境的**内部**有两个组件：(1) **环境记录器**和 (2) 一个**外部环境的引用**。

1. **环境记录器**是存储变量和函数声明的实际位置。
2. **外部环境的引用**意味着它可以访问其父级词法环境（作用域）。

**词法环境**有两种类型：

- **全局环境**（在全局执行上下文中）是没有外部环境引用的词法环境。全局环境的外部环境引用是 **null**。它拥有内建的 Object/Array/等、在环境记录器内的原型函数（关联全局对象，比如 window 对象）还有任何用户定义的全局变量，并且 `this`的值指向全局对象。

- 在**函数环境**中，函数内部用户定义的变量存储在**环境记录器**中。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。

**环境记录器**也有两种类型（如上！）：

1. **声明式环境记录器**存储变量、函数和参数。
2. **对象环境记录器**用来定义出现在**全局上下文**中的变量和函数的关系。

简而言之，

- 在**全局环境**中，环境记录器是对象环境记录器。
- 在**函数环境**中，环境记录器是声明式环境记录器。

**注意 —** 对于**函数环境**，**声明式环境记录器**还包含了一个传递给函数的 `arguments` 对象（此对象存储索引和参数的映射）和传递给函数的参数的 **length**。



#### 变量环境：

它同样是一个词法环境，其环境记录器持有**变量声明语句**在执行上下文中创建的绑定关系。

如上所述，变量环境也是一个词法环境，所以它有着上面定义的词法环境的所有属性。

在 ES6 中，**词法环境**组件和**变量环境**的一个不同就是前者被用来存储函数声明和变量（`let` 和 `const`）绑定，而后者只用来存储 `var` 变量绑定。

## 作用域链

1. JavaScript ，作用域是用来规定变量与函数可访问范围的一套规则

2. 最常见的作用域有两种，分别是全局作用域与函数作用域
3. 作用域链（ Scope Chain ）是由当前执行环境与上层执行环境的一系列变量对象组成的，它保证了当前执行环境对符合访问权限的变量和函数的有序访问
4. 作用域：当前的执行上下文。[值](https://developer.mozilla.org/en-US/docs/Glossary/value)和**表达式**在其中 "可见" 或可被访问到的上下文。如果一个**[变量](https://developer.mozilla.org/en-US/docs/Glossary/variable)**或者其他表达式不 "在当前的作用域中"，那么它就是不可用的。 作用域也可以根据代码层次分层，以便子作用域可以访问父作用域，通常是指沿着链式的作用域链查找，而不能从父作用域引用子作用域中的变量和引用。当然，一个 [Function](https://developer.mozilla.org/zh-CN/docs/Glossary/Function) 将生成一个闭包（通常是返回一个函数引用），这个函数引用从外部作用域（在当前环境下）可以访问闭包内部的作用域。

## 闭包

一个函数和对其周围状态（**lexical environment，词法环境**）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是**闭包**（**closure**）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。



https://juejin.cn/post/6844903769646317576

