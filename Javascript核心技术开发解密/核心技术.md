## 2内存空间管理

> 标记清除算法
>
> 垃圾回收程序会标记内存种存储的所有变量，然后将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉，此后剩下的就是待删除的变量了。
>
> 引用计数

## 3执行上下文

> JavaScript 代码在执行时，会进入 个执行上下文中 执行上下文可以理解为当前代码的运
>
> 行环境
>
> JavaScript 中的运行环境主要包括以下 种情况
>
> - 全局环境：代码运行起来后会首先进入全局环境
>
> - 函数环境：当函数被调用执行时，会进入当前函数中执行代码
>
> - eval环境：不建议使用，这里不做介绍
>
> 生命周期
>
> - 创建阶段
>     - 创建变量对象
>     - 确认作用域链
>     - 确定this指向
> - 执行阶段
>     - 变量赋值
>     - 函数引用
>     - 执行其他代码
> - 执行完毕后出栈，等待被回收

## 4变量对象

> 包括
>
> - 函数的所有参数（arguments）
> - 当前上下文中的所有函数声明（function声明的函数）
> - 当前上下文的所有变量声明（var声明的变量）
>
> 例外
>
> 全局上下文的变量对象
>
> - 全局上下文的变量对象为window对象，且全局上下文的变量对象不能变成活动对象

## 5作用域与作用域链

### 作用域

> （不知道js：）作用域负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。作用域是用来规定变量与函数可访问范围的一套规则。

> （MDN：）当前的执行上下文。[值](https://developer.mozilla.org/en-US/docs/Glossary/Value)和**表达式**在其中 "可见" 或可被访问到的上下文。如果一个**[变量](https://developer.mozilla.org/en-US/docs/Glossary/Variable)**或者其他表达式不 "在当前的作用域中"，那么它就是不可用的。 作用域也可以根据代码层次分层，以便子作用域可以访问父作用域，通常是指沿着链式的作用域链查找，而不能从父作用域引用子作用域中的变量和引用。
>
> （别人总结：）
>
> 作用域是指程序源代码中定义变量的区域。
>
> 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。
>
> JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。
>
> 
>
> 最常见的作用域有两种，分别是全局作用域与函数作用域
>
> - 全局作用域中声明的变量与函数可以在代码的任何地方被访问
>
> - 函数作用域中声明的变量与方法，只能被下层子作用域访问，而不能被其它不相干的作用域
>
>     访问



### 作用域链

> 作用域链（ Scope Chain ）是由当前执行环境与上层执行环境的一系列变量对象组成的，它保证了当前执行环境对符合访问权限的变量和函数的有序访问
>
> （别人总结：）当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。

## 6闭包

> 闭包是一种特殊的对象？？闭包是指那些能够访问自由变量的函数。（函数也是对象？）
>
> - 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。
> - 闭包 = 函数 + 函数能够访问的自由变量
> - 从技术的角度讲，所有的JavaScript函数都是闭包。
>
> 它由两部分组成执行上下文（代号A），以及在该执行上下文中创建的函数（代号B）。
>
> 当B执行时，如果访问了A中变量对象中的值，那么闭包就会产生。
>
> 许多书籍 文章里都以函数B的名字代指这里生成的闭包 而在 Chrome 中，则以执行上下问A的函数名代指闭包

> 闭包是指这样的作用域（ foo ），它包含了一个函数（ fnl ），这个函数（ fnl ）可以调用被这个作用域所封闭的变量（a）、函数或者闭包等内容 通常我们通过闭包所对应的函数来获得对闭包的访问

> 闭包的本质就是在函数外部保持了内部变量的引用，因此闭包会阻止垃圾回收机制进行回收

> 在这里需要特别注意的地方是函数调用栈（CallStack）与作用域链（Scope）的区别
>
> 因为函数调用栈其实是在代码执行时才确定的，而作用域规则在代码编译阶段就已经确定，虽然作用域链是在代码执行时才生成的，但是它的规则并不会在执行时发生改变
>
> 所以这里闭包的存在并不会导致作用域链发生变化

## 7this

> 在一个函数的执行上下文中， this 由该函数的调用者提供，由调用函数的方式来决定其指向

> 如果调用者被某 个对象所 有，那么在调用该函数 thi 指向该对象 如果调用者函数独立调用，那么该函数内部的 thi 则指向 undefined 但是在非严格模式中， this 指向ndefined 时，它会自动指向全局对象

## 8函数与函数式编程

> 在变量对象的创建过程中， function 声明的函数比 va 明的变量有更加优先的执行顺序，即我们常常提到的函数声明提前 在同一执行上下文中，无论在什么地方声明了函数，都可以接使用

> 匿名函数就当成函数来理解即可，而闭包的形成条件，仅仅只是有的时候会和匿名函数有关而已



## 10ES6与模块化

> 任务队列又分为宏任务（ macro-task ）与微任务（ micro-task ）两种，在浏览器中，包括：
>
> @ macro-task: script （整体代码）、 setTimeout/setlnterval ν0 UI rendering
>
> @ micro-task: Promise

> codepen.io 在线的模块化学习环境
>
> 