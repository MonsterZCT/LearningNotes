# 核心技术

## 5作用域与作用域链

### 作用域

> 作用域是用来规定变量与函数可访问范围的一套规则

> 函数作用域中声明的变量与方法，只能被下层子作用域访问，而不能被其 不相干的作用域访问



### 作用域链

> 作用域链（ Scope Chain ）是由当前执行环境与上层执行环境的一系列变量对象组成的，它保证了当前执行环境对符合访问权限的变量和函数的有序访问



## 6闭包

> 闭包是一种特殊的对象
>
> 它由两部分组成书 行上下文（代号A），以及在该执行上下文中创建的函数（代号B）。
>
> 当B执行时，如果访问了A中变量对象中的值，那么闭包就会产生。
>
> 许多书籍 文章里都以函数B的名字代指这里生成的闭包 而在 Chrome 中，则以执行上下问A的函数名代指闭包

> 闭包是指这样的作用域（ foo ），它包含了一个函数（ fnl ），这个函数（ fnl ）可以调用被这个作用域所封闭的变量（a）、函数或者闭包等内容 通常我们通过闭包所对应的函数来获得对闭包的访问

> 闭包的本质就是在函数外部保持了内部变量的引用，因此闭包会阻止垃圾回收机制进行回收

> 在这里需要特别注意的地方是函数调用钱（CallStack）与作用域链（Scope）的区别
>
> 因为函数调用战其实是在代码执行时才确定的，而作用域规则在代码编译阶段就已经确定，虽然作用域链是在代码执行时才生成的，但是它的规则并不会在执行时发生改变
>
> 所以这里闭包的存在并不会导致作用域链发生变化

## 7this

> 在一个函数的执行上下文中， this 由该函数的调用者提供，由调用函数的方式来决定其指向

> 如果调用者被某 个对象所 有，那么在调用该函数 thi 指向该对象 如果调用者函数独立调用，那么该函数内部的 thi 则指向 undefined 但是在非严格模式中， this 指向ndefined 时，它会自动指向全局对象

## 8函数与函数式编程

> 在变量对象的创建过程中， function 声明的函数比 va 明的变量有更加优先的执行顺序，即我们常常提到的函数声明提前 在同一执行上下文中，无论在什么地方声明了函数，都可以接使用

> 匿名函数就当成函数来理解即可，而闭包的形成条件，仅仅只是有的时候会和匿名函数有关而已



## 10ES6与模块化

> 任务队列又分为宏任务（ macro-task ）与微任务（ micro-task ）两种，在浏览器中，包括：
>
> @ macro-task: script （整体代码）、 setTimeout/setlnterval ν0 UI rendering
>
> @ micro-task: Promise

> codepen.io 在线的模块化学习环境
>
> 